import numpy as np
import matplotlib.pyplot as plt

# Параметры для степенного и экспоненциального затухания
A = 0.004    # амплитуда степенного затухания
B = 5.0      # амплитуда экспоненциального затухания (пример, как в Fig.1)
tau = 0.1    # постоянная времени экспоненциального затухания, c (пример 0.1 s)

# Можно легко менять эти параметры для случая tau=0.5, B=2 и т.д.

def step_response(t, A, B, tau):
    """
    Суммарный отклик S(t) = P(t) + E(t),
    где P(t) = A * t^(-3/2), E(t) = B * exp(-t/tau),
    но только для t>0. Для t<=0 вернём 0 (идеализированный шаг).
    """
    # Избегаем деления на ноль: для t=0 зададим значение 0.
    # В реальности TЕМ-сигнал не определён строго в t=0,
    # но для численной модели мы поставим S(0)=0.
    resp = np.zeros_like(t)
    positive_mask = (t > 0)
    
    # Степенное затухание
    p = A * t[positive_mask]**(-1.5)
    # Экспоненциальное затухание
    e = B * np.exp(-t[positive_mask]/tau)
    
    resp[positive_mask] = p + e
    return resp

def simulate_tem_signal(f, A, B, tau, t_max=1.0, dt=1e-4):
    """
    Моделируем повторяющиеся импульсы с частотой f.
    Каждый период начинается "шагом" (в момент t = nT),
    после чего затухание идёт до следующего импульса.
    
    :param f: частота повторения (Гц)
    :param A, B, tau: параметры отклика
    :param t_max: сколько секунд моделировать
    :param dt: шаг по времени
    :return: массив (t, s) - время и суммарный сигнал
    """
    T = 1.0 / f  # период
    t_array = np.arange(0, t_max, dt)
    s_array = np.zeros_like(t_array)
    
    # Идём по временной шкале и для каждого периода добавляем вклад шага
    # Упрощённо: в момент t = n*T возникает "шаг", добавляем S(t - nT)
    # с учётом, что S(t)=0 для t<0.
    # Складываем все "хвосты" воедино (суперпозиция).
    # Это упрощённый подход, в статье же делают свёртку с формой сигнала.
    
    # Максимальное число периодов, которое поместится в t_max
    n_periods = int(np.ceil(t_max / T))
    
    for n in range(n_periods):
        t_start = n * T
        # Время, прошедшее после шага
        t_local = t_array - t_start
        # Получаем отклик
        s_local = step_response(t_local, A, B, tau)
        # Суммируем в общий сигнал
        s_array += s_local
    
    return t_array, s_array

# --- Демонстрация для нескольких частот ---
freqs = [1, 5, 30] # 0.125, 0.25, 0.5, 1, 2, 4, 8, 16
t_max = 1.0  # Общее время моделирования, при более низких частотах можно увеличить

plt.figure(figsize=(8, 6))

for f in freqs:
    t, s = simulate_tem_signal(f, A, B, tau, t_max=t_max, dt=1e-4)
    plt.plot(t, s, label=f'{f} Hz')

plt.xscale('log')
plt.yscale('log')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude (pT, условные)')
plt.title('Упрощённая модель повторяющихся импульсов TEM\n(Влияние частоты на затухание)')
plt.legend()
plt.grid(True)
plt.show()
 

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import inv
from scipy.stats import chi2

# Solution to seismic profile Exercise 2.1

# Constants
d0 = 2
v1 = 3
v2 = 5

# Critical angle
thetac = np.arcsin(v1/v2)

# Horizontal offset to critical refraction
x0 = d0 / np.tan(thetac)

# Start and end of refraction
xstart = 2 * x0
xmax = 5 * xstart

# True parameters
t0 = 2 * np.sqrt(d0**2 + x0**2) / v1
s2 = 1 / v2

# Number of data points
M = 6
x = np.linspace(np.ceil(xstart), xmax, M)

# Solve the least squares regression
# Generate a data set
G = np.vstack([np.ones(M), x]).T
dof = M - 2
sig = 0.1

# Data noise vector
noise = sig * np.ones(M)
# Load canned data (for HW)
t = np.array([3.4935, 4.2853, 5.1374, 5.8181, 6.8632, 8.1841])

# Weight the system
Gw = G / noise[:, None]
tw = t / noise

# a) Find the 2-norm solution
print('2-norm solution:')
m2 = np.linalg.lstsq(Gw, tw, rcond=None)[0]

# Plot the data predictions and data for the 2-norm solution
plt.errorbar(x, t, yerr=noise, fmt='*')
plt.plot(x, m2[0] + x * m2[1], 'r')
plt.xlabel('x (km)')
plt.ylabel('t (s)')
plt.show()

# b) Generate the covariance and correlation matrices; plot the error ellipsoid
print('Covariance matrix:')
covm = sig**2 * inv(G.T @ G)
print(covm)

print('Correlation matrix:')
s = np.sqrt(np.diag(covm))
rhom = covm / (s[:, None] * s[None, :])
print(rhom)

# Plot the error ellipsoid
u, lam = np.linalg.eig(covm)
theta = np.linspace(0, 2 * np.pi, 100)
r1 = 2.45 * np.sqrt(lam[0]) * u[0, 0] * np.cos(theta) + np.sqrt(lam[1]) * u[0, 1] * np.sin(theta)
r2 = 2.45 * np.sqrt(lam[0]) * u[1, 0] * np.cos(theta) + np.sqrt(lam[1]) * u[1, 1] * np.sin(theta)

plt.plot(m2[0] + r1, m2[1] + r2)
plt.axis('equal')
plt.xlabel('t_0 (s)')
plt.ylabel('s_2 (s/km)')
plt.show()

# c) Chi-square calculations
print('Chi-square value:')
chi2_value = np.linalg.norm((G @ m2 - t) / noise)**2
print(chi2_value)

print('Chi-square p value:')
p = 1 - chi2.cdf(chi2_value, dof)
print(p)

# d) Monte Carlo Calculations
# The baseline data set generated by the 2-norm model
db = G @ m2

# Number of realizations for Monte Carlo
NR = 1000
chi2r = np.zeros(NR)
mr2 = np.zeros((2, NR))

for i in range(NR):
    # Generate the data vector for the ith Monte Carlo data set
    dr = db + noise * np.random.randn(M)
    # Calculate the weighted data vector
    dw = dr / noise
    # Find the 2-norm model for the ith Monte Carlo data set, stored as a column of mr2
    mr2[:, i] = np.linalg.lstsq(Gw, dw, rcond=None)[0]
    # Calculate the chi-square value for the ith Monte Carlo data set
    chi2r[i] = np.linalg.norm((G @ mr2[:, i] - dr) / noise)**2

# Histogram the chi2 values for the Monte Carlo realizations and compare with the chi2 PDF
plt.figure()
plt.subplot(2, 1, 1)
plt.hist(chi2r, bins=20)
plt.xlabel(r'$\chi^2_{obs}$')
plt.ylabel('N')

# Plot chi-squared PDF
xx = np.linspace(0, 20, 200)
chitheo = chi2.pdf(xx, dof)
plt.subplot(2, 1, 2)
plt.plot(xx, chitheo)
plt.ylabel(r'$\chi^2(\nu=4, x)$ PDF')
plt.xlabel('x')
plt.axis([0, 20, 0, max(chitheo)])
plt.show()

# Solve and plot the L-1 solution
print('1-norm solution:')
# Implementing IRLS or use a similar function
# m1 = irls(Gw, tw, 1.0e-8, 1.0e-6, 1, 100)

# Placeholder for the IRLS solution (implement or use an external IRLS method)
m1 = np.array([0, 0])  # This should be replaced with the IRLS solution

# Plot the data predictions and data for the 1-norm solution
plt.errorbar(x, t, yerr=noise, fmt='*')
plt.plot(x, m1[0] + x * m1[1], 'r')
plt.xlabel('x (km)')
plt.ylabel('t (s)')
plt.show()

# Monte Carlo for L-1 solution
mr1 = np.zeros((2, NR))
for i in range(NR):
    # Data vector for the ith Monte Carlo data set
    dr = db + noise * np.random.randn(M)
    # Weighted data vector
    dw = dr / noise
    # 2-norm model for the ith Monte Carlo data set
    mr1[:, i] = np.array([0, 0])  # Replace with the actual IRLS function

# Estimate L1 confidence intervals
mrmean1 = np.mean(mr1, axis=1)
m1sort = np.sort(np.abs(mr1[0, :] - mrmean1[0]))
m2sort = np.sort(np.abs(mr1[1, :] - mrmean1[1]))
m11conf = m1sort[int(0.95 * NR)]
m12conf = m2sort[int(0.95 * NR)]
print(f'm1 Monte Carlo modeling 95% confidence width (indiv. parameters): ({m11conf}, {m12conf})')

m11range = [m1[0] - m11conf, m1[0], m1[0] + m11conf]
